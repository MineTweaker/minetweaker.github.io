
## Intro
**MineTweaker** is a mod that enables players and server admins to alter recipes (both crafting recipes, furnace recipes and now also some mod machine recipes) as well as changing some small things such as item names, fuel burning times, ... For all these functions, MineTweaker uses a fully scripted language, making it easy to understand and offering a lot of functionality.

Minetweaker a Forge mod. Put it in the mods directory and start the game. An empty config file will be generated automatically in the config/minetweaker folder. Edit the file to define the behavior of MineTweaker. Check the in-game command /help minetweaker to get information about the in-game commands available.

With the 1.6 launcher, debugging your scripts is easy because the launcher contains its own console. MineTweaker prints all its modifications and errors to that console window. Amongst all the output generated by Forge and the loaded mods, you will find lines starting with Minetweaker telling you what it's doing, which alterations it has made, and which errors have been encountered, if any.

## Scripts
MineTweaker uses scripts to define its behavior. There are two ways to store scripts:
- **Local**, in a folder `minetweaker` in the config directory
- **Server-side**, in a folder `minetweaker` in the savegame directory

If local scripts are used, they must be the same between server and client. If server-side scripts are used, they only have to be defined on the server and they will be automatically sent to the client and executed when the client connects. When the client disconnects from the server, any changes made by the server scripts are rolled back. Server-side scripts thus enable custom recipes and values without having to worry about getting them synchronized with the clients.

Local and server scripts both start execution at `main.cfg`. This file can then include other files in its directory or any of its subdirectories.

In `main.cfg`, the first statement must be a version statement: `version 2;`, which is automatically generated when the mod it started for the first time. If you had a version 1 script, it will be automatically converted to the new script format.

Further statements can:
- Declare new recipes or remove old recipes
- Alter the ore dictionary
- Set displayed item names

## IDs and item names
Note that the first command uses the full item name. If you don't know the item name, use the in-game command ```/minetweaker name <itemid>``` (for example ```/minetweaker name 41```). Using item names is recommended as it makes names independent of the ID assignments.

If an item starts with "tile." (for blocks) or "item." (for items), they can be accessed directly using their full name. (```tile.blockGold```, for instance). However, mods often have items or blocks with names which do not start with "tile." or "item." . As fallback, all items and blocks, including those starting with "tile." and "item.", can be accessed using the items and blocks values. (for instance, the IC2 rotary macerator is accessible via `blocks.blockRotaryMacerator`)

Item IDs must be placed inside **angled brackets**, otherwise scripting engine will recognize it as a number and not as an item ID. You can use simple IDs (for example, `<41>` for the gold block) or `id:meta` pairs (for example, `<35:3>` for yellow wool).

Be aware of the difference between item `<35>` and item `<35:0>`. The first item denotes any kind of wool block, and running `/minetweaker name 35` will give you tile.cloth, the internal generic name of wool blocks. If using the item (either from its ID, `<35>`, or name, `tile.cloth`) in a recipe, the recipe will accept any kind of wool, and if using it as an output, it will create item `35:0`, which is white wool. Running `/minetweaker name 35:0` will give you `tile.cloth.white`, which is white wool. Using that in a recipe, the recipe will accept only white wool, but not any kind of colored wool. Also note that when using NEI to look up item IDs, the :0 meta-value will not be shown even though the item really uses ID `<X:0>` and not ID `<X>`.

## Recipes
To remove any and all known recipes that result in a certain item, use ```minetweaker.remove```. The following examples all remove the Gold Block recipe:

`minetweaker.remove(tile.blockGold);
minetweaker.remove(<41>);
minetweaker.remove(<35:0>);`

You can also go more specific and use the `recipes.remove` command. For example:

`recipes.remove(tile.blockGold);`

Such code will only remove crafting recipes, but not, for instance, smelting recipes.

You can even go more specific and remove only shaped or shapeless recipes:

`recipes.removeShaped(tile.blockGold);
recipes.removeShapeless(tile.blockGold);`

If you want to remove a *specific* recipe, that is possible too:

`gold = item.ingotGold;
recipes.removeShaped(tile.blockGold, [[gold, gold, gold], [gold, gold, gold], [gold, gold, gold]]);
recipes.removeShapeless(tile.cloth, [tile.cloth, oreDict.dyeYellow]);`

Note that in this example, we assign `item.ingotGold` to the name `gold` to not repeat `item.ingotGold` every time. Also note the usage of the yellow dye ore dictionary item. Also notes that shaped recipes expect a two-dimensional array (each subarray being a row of the crafting recipe) and the shapeless recipes expect a one-dimensional array (simply listing the contents of the shapeless recipe, the order of items doesn't matter).

## Adding recipes

`gold = item.ingotGold;`
`wood = oreDict.plankWood;`

`recipes.addShaped(tile.blockGold,[[wood, gold, wood],[gold, gold, gold],[wood, gold, wood]]);`

`recipes.addShaped(gold * 5, [[tile.blockGold]]);`

`recipes.addShapeless(tile.oreGold, [gold, tile.stone]);`

Note the usage of the `* 5` multiplier in the second recipe. This means that the recipe will craft 5 of these items instead of just one.

Multipliers can also be used in the `remove` commands. By default, a `remove` command doesn't care how many items are crafted with the recipe. However, with the multiplier, it becomes sensitive to the amount of items crafted:

`minetweaker.remove(item.ingotGold * 9);`

This instruction will remove only the ore to ingots recipe, but not, for instance, the gold ingot smelting recipe. Similarly, `minetweaker.remove(item.ingotGold * 1)` would only remove the gold ingot smelting recipe but not the block to ingot recipe.
<br>
You can also do this:

`anyWood = oreDict.plankWood.any;`
`recipes.removeShaped(<*>, [[anyWood, null, null], [anyWood, anyWood, null], [anyWood, anyWood, anyWood]]);`

This instruction will remove all stairs recipes.
<br>
Why did we use `oreDict.plankWood.any` and not just `oreDict.plankWood`? Using `oreDict.plankWood` would only match recipes that use the ore dictionary as their recipe contents. However, the stairs recipes are defined for specific wood types (birch, oak, ...) and thus would not match. With `oreDict.plankWood.any` we specify that we want any kind of wood to match, and not just the `plankWood` oredictionary entry. Similarly, using `remove` with `oreDict.plankWood.any` will remove all recipes that craft any kind of wood.

Also note the wildcard value `<*>`. This means: "match any item". Doing `minetweaker.remove(<*>)` would, for example, make all items uncraftable.

What about subitems? Most of the time, subitems are handled transparently for you, but sometimes you need to do subitem work. A subitem is automatically created when you load it by its name, for instance:

`recipes.remove(tile.cloth.orange);` # remove orange wool crafting recipe
`recipes.remove(tile.cloth);` # remove all wood crafting recipes
`recipes.remove(<35:4>);` # remove yellow wool crafting recipe

Likewise, using `tile.cloth` as recipe ingredient will allow any color of wool to be used, while `tile.cloth.white` would only allow white wool.

Since version 2.2.2, it is also possible to craft damaged items:

`recipes.addShaped(item.pickaxeWood.withDamage(1), ...recipe...);`

<br>

Now you are able to make your own recipes. But what if your output items should have their damage or NBT tags set? Now this is possible with crafting functions. Consider the following statement:

    recipes.addShapeless(item.pickaxeWood, [item.pickaxeWood.damaged, item.axeWood.damage], function(output, input) {
    output.damage = max(0, output.maxDamage - (input[0].maxDamage - input[0].damage) - (input[1].maxDamage - input[1].damage) - output.maxDamage * 0.1);
    });

This will make Wooden Pickaxe repairable by combining it with a Wooden Axe. Now, this example may not be very interesting, but this functionality makes it possible to add repair recipes in case your favorite mod forgot to include them. Also notice the usage of `item.damaged`: by default, damaged items cannot be used as crafting ingredients, but using .damaged enables the use of damage items as well.

Now we can also make it more interesting. You can also set NBT tags with these functions. This recipe crafts awesome gold ingots:

    recipes.addShapeless(item.ingotGold, [item.ingotGold, item.ingotIron], function(output, input) {
        output.tag = {
            "display": { "Name": "Awesome gold ingot" }
        };
    });

Now when you craft a gold and iron ingot together, it will create a gold ingot with the name "Awesome gold ingot" as if you set the name using the anvil.

This can be used for anything that uses NBT tags. For example, enchantments:

    recipes.addShapeless(item.pickaxeDiamond, [item.pickaxeDiamond, item.netherStar], function (output, input) {
        output.tag = {
            "RepairCost": 2,
            "ench": [
                {"id": 33 as short, "lvl": 1 as short }
            ]
        };
    });

Combining a Diamond Pickaxe with a Nether Star now gives a Silk Touch Diamond Pickaxe! Notice the `as short` after the values. Enchantment IDs and levels require short values, but by default integer constants are int values, thus they need to be converted. If you were to omit the conversions, it would store it as an int, and crash the game.

This functionality can also be used to define mod item recipes that would otherwise be uncraftable. Just use an NBT editor to discover the structure of the item and replicate that structure exactly in you crafting recipes. (note: if you need a byte array, `as byte[]` will give that. Using `as int[]` will give an int array. `[1, 2]` will result in a list tag. `[1, 2] as int[]` will result in an int array tag)


## Furnace
Furnace recipes can be removed:
`furnace.remove(item.ingotGold);` # remove the gold ingot smelting recipe.

You can also go more specific with the `removeRecipe` method:

`furnace.removeRecipe(item.ingotGold, tile.oreGold);`

Adding furnace recipes:

`furnace.remove(item.ingotGold);
furnace.addRecipe(item.ingotGold * 2, tile.oreGold);`
Now gold ore gives you two gold ingots instead of one.

But now it doesn't give any XP anymore. No problem, since that can be fixed easily by altering our code a little bit:

`furnace.remove(item.ingotGold);
furnace.addRecipe(item.ingotGold * 2, tile.oreGold, 1.0);`

Now you get some XP too. The latter value can be modified to give more or less XP.

It is also possible to add and remove furnace fuels as well as changing existing fuels, all with one simple statement:

`tile.leaves.fuel = 40;`

Remember when you used to burn dry leaves as kid and have it burn in a strong and quick flame? Now you can do it in minecraft furnaces too! In this example, it will burn for 40 ticks (2 seconds) so you better have some supply available if you want to use it as fuel.

Setting an item's fuel value to 0 will make it no longer work as fuel. It is also possible to use `oreDict.xx.any` values to make all items from that entry burnable. If a value is set for both a specific item as well as its ore dictionary value, the item-specific value will take precedence.

## Ore Dictionary
Unless you skipped the first paragraphs, you should already know how to use ore dictionary entries and ore dictionary `.any` values. But it's also possible to alter the ore dictionary, and quite easily so:

`oreDict.plankWood.add(tile.leaves);`

Now leaves can magically be used as wood too. Handy if your mod forgot to add its custom wood to the ore dictionary.

It's also possible to define new ore dictionary items simply by using an ore dictionary name that doesn't exist yet:

`oreDict.myAnyIngot.add(item.ingotGold);
oreDict.myAnyIngot.add(item.ingotIron);`

Items can be removed too:
`oreDict.plankWood.remove(tile.wood);`

Now, this example may not be very practical, but I can sure imagine cases where you find certain recipe item alternatives too cheap and want them removed.

## Item Names
If an item happens to be missing its name, or you don't like the item name, it can be changed easily:

`item.ingotIron.displayName = "The Iron Ingot";
item.ingotIron.setDisplayName("The Iron Ingot");`# does the same

Or, if you want to go international:

`item.ingotIron.setDisplayName("nl_NL", "De ijzeren ingot");`# sets the item name for Dutch translation

## Liquids
MineTweaker now also has support for liquids. These liquids are used in certain mods, such as buildcraft fuels or the refinery recipes.

Liquid values can be obtained through their source block ID or name:

`print(tile.water.displayName);`

They can also be obtained through their container:

`print(item.bucketLava.liquid.displayName);
print(<293>.liquid.displayName);`


They can also be obtained through their registered name:

`print(fluid.tile.water.displayName);`

If their name does not start with `fluid.`, they can be obtained from fluids just like items and blocks can be used to retrieve items with non-standard names. Their name can be retrieved with the command `/minetweaker liquid <containerItemId>` or `/minetweaker liquid <sourceBlockId>`.

**Liquid containers** can be added or removed:

`lavaLiquid = item.bucketLava.liquid;`

`lavaLiquid.addContainer(tile.cobblestone, 0.1, tile.hellrock);`# registers netherrack as cobblestone containing 0.1 buckets of lava

`lavaLiquid.removeContainer(item.bucketLava);`

Now try putting netherrack in a liquid transposer - it can take a bit of lava out of the netherrack. The lava bucket, however, won't work anymore.

In 1.6.2, additional fields are available:

`print(fluid.tile.water.temperature);`
`print(fluid.tile.water.density);`
`print(fluid.tile.water.luminosity);`
`print(fluid.tile.water.gaseous);`

These fields are settable too. In minecraft 1.5.2, reading them results in zero and setting them does nothing other than printing a warning.


## Server scripts and clear()
When MineTweaker starts, it will first execute the scripts in its `config/minetweaker` directory. When the player joins the server (or the server starts) it will then execute
the scripts from the server's savegame minetweaker directory. By default, these changes will supplement the changes already made. It is possible to undo the modifications that have been made before with the `minetweaker.clear` command:

`minetweaker.clear();`# undoes all modifications done so far

Although all non-mod modifications can be undone, it will not always be possible to do so. Some mods have alterations that cannot be rolled back. When any such modification has been performed, it will break the clear function (and generate an exception). Additionally, when such permanent modification is executed in a server script, the player will have to restart minecraft to join another game. The player can still rejoin the same game as long as the server scripts haven't changed.

To check if `clear()` will work, wrap it in a canClear test:

`if (minetweaker.canClear()) {
minetweaker.clear();
} else {`# do stuff in case we can't clear
`}`

## Multi-file scripts
Scripts start execution at main.cfg. Other files can be put in minetweaker directories and although not executed by default, can be included with include statements:

`include "subfile.cfg";`

This will include the file names "subfile.cfg" and execute its contents. The variables created by this file will be accessible when the file exist. If you do not want such behavior you can wrap the include in a block statement:

`{
    include "subfile.cfg";
}`

Note, however, that `subfile.cfg` can still change existing variables.

Subdirectories can be created and files loaded from them:

`include "subdir/subfile.cfg";`

Scripts cannot include files outside the minetweaker directory. Note that servers will send all the files in their minetweaker directory (and subdirectories) to the client, even if not used.

## Mod Support
Currently MineTweaker has mod integration support with **BuildCraft**, **IndustrialCraft 2**, **GregTech** and **Forestry**. Most of the machines can have recipes added to them, sometimes recipes can be removed as well.

Keep in mind that not all actions can be undone. If an action in a server-side script is not undoable, the server must restart the game in order to join another game with a different script (or if the game had its scripts changed). Actions that cannot be undone are marked and a warning will be generated in the console when such action is executed.

## BuildCraft
It is possible to alter Buildcraft's assembly table and refinery recipes, as well as defining new engine fuels and coolants.

**Assembly table**:

`modSupport.buildcraft.assemblyTable.addRecipe(item.netherStar, 100000, [item.diamond, item.skull.wither]);`

`modSupport.buildcraft.assemblyTable.remove(item.pipeGateAutarchic.0);`

`modSupport.buildcraft.assemblyTable.removeRecipe(<*>, [item.redstone, item.redstoneChipset.3]);` # removes diamond gate recipes

`modSupport.buildcraft.assemblyTable.setEnergy(item.redstoneChipset.2, 1000);` # make golden chipset pretty cheap energy-wise

The second argument to addRecipe is the energy cost in MJ. (in comparison: the redstone to redstone chipset recipe costs 10000MJ) Remove and RemoveRecipe work just like all the other ones present in MineTweaker and item patterns will work just fine. Note that ore dictionary entries cannot be used at assembly table recipe items.

**Refinery**:

`modSupport.buildcraft.refinery.addRecipe(tile.lava, 12, 1, tile.water);` # converts water to lava

`modSupport.buildcraft.refinery.remove(item.bucketFuel.liquid);`

Putting water in the refinery will now convert it to lava. It will take 1 tick for 1 millibucket and consume 12 MJ per millibucket. Removing recipes works as well.

It's also possible to have the refinery take two different liquids and convert them to another liquid. To do so, add another liquid as argument to the addRecipe function.

Fuels can be added and removed too, as well as some other things:

`modSupport.buildcraft.fuels.add(tile.water, 1, 1000);` # make water generate 1MJ/cycle for 1000 cycles

`modSupport.buildcraft.fuels.remove(item.bucketOil.liquid);` # oil doesn't work as fuel anymore

`print(modSupport.buildcraft.fuels[tile.water].liquid.displayName);`
`print(modSupport.buildcraft.fuels[tile.water].powerPerCycle);`
`print(modSupport.buildcraft.fuels[tile.water].totalBurningTime);`

The fields `powerPerCycle` and `totalBurningTime` are also settable.

For the buildcraft filler, "soft" blocks can be removed by the filler (without dropping anything). Soft blocks can be added or removed with minetweaker:

`modSupport.buildcraft.setSoftBlock(tile.water, true);`
`modSupport.buildcraft.setSoftBlock(tile.grass, false);`

Now the filler will automatically remove still water blocks, but not grass blocks.

## IndustrialCraft 2
The IC2 mod support interface supports the addition and removal of the compressor, extractor and macerator recipes:

`modSupport.ic2.macerator.remove(tile.sand);` # remove cobble to sand recipe
`modSupport.ic2.macerator.removeRecipe(item.ironDust, item.ironOre);` # remove iron ore to iron dust recipe
`modSupport.ic2.macerator.addRecipe(tile.sand * 4, tile.sandstone);` # macerates sandstone into 4 sand

The three methods (`remove`, `removeRecipe` and `addRecipe`) are available for each of the three machines.

In Minecraft 1.6, only the `addRecipe` method is available. Recipes cannot be removed due to the API limitations. In 1.6, IC2 machines also support ore dictionary values. In Minecraft 1.5, ore dictionary values cannot be used in machine recipes.

The new machines are also available:

`modSupport.ic2.metalFormer.cutting.addRecipe(output, input);`

`modSupport.ic2.metalFormer.rolling.addRecipe(output, input);`

`modSupport.ic2.metalFormer.extruding.addRecipe(output, input);`

`modSupport.ic2.centrifuge.addRecipe([output1, output2, output3], input, minHeat);`

`modSupport.ic2.oreWashingPlant.addRecipe([output1, output2, output3], input);`

`modSupport.ic2.oreWashingPlant.addRecipe([output1, output2, output3], input, millibucketsOfWater);`

## GregTech
All GregTech machines are supported, in all versions. However, recipes can only be added, never removed. For all the machines, the duration is measured in ticks (1 second = 20 ticks) and energy consumption in EU per tick. None of the gregtech functions are undoable!

Be aware that GregTech doesn't support ore dictionary values in its machine recipes.

**Alloy Smelter**:

`modSupport.gregtech.alloySmelter.addRecipe(output, input1, input2, duration, euPerTick);`
<br>
**Assembler**:

`modSupport.gregtech.assembler.addRecipe(output, input1, input2, duration, euPerTick);`

`modSupport.gregtech.assembler.addRecipe(output, input, null, duration, euPerTick);`
<br>
**Blast Furnace**:

`modSupport.gregtech.blastFurnace.addRecipe(output, input1, input2, duration, euPerTick, minimumHeat);`

`modSupport.gregtech.blastFurnace.addRecipe(output, input, null, duration, euPerTick, minimumHeat);`
<br>
**Canner**:
`modSupport.gregtech.canner.addRecipe(output, input);`
`modSupport.gregtech.canner.addRecipe(output, input1, input2);`
`modSupport.gregtech.canner.addRecipe(output, input1, input2, duration);`
`modSupport.gregtech.canner.addRecipe(output, input1, input2, duration, euPerTick);`
`modSupport.gregtech.canner.addRecipe(output, input, null, duration);`
`modSupport.gregtech.canner.addRecipe(output, input, null, duration, euPerTick);`

By default, canning takes 100 ticks at 1 EU/tick.
<br>
**Chemical Reactor**:

`modSupport.gregtech.chemical.addRecipe(output, input1, input2, duration);`
<br>
**Cutter**:

`modSupport.gregtech.cutter.addRecipe(output, input, duration, euPerTick);`
<br>
**Distillation Tower**:

`modSupport.gregtech.distillationTower.addRecipe([output1, output2, output3, output4], input, cells, duration, euPerTick);`

The distillation tower can have 1-4 outputs.
<br>
**Electrolyzer**:
`modSupport.gregtech.electrolyzer.addRecipe([output1, output2, output3, output3], input, numCells, duration, euPerTick);`

The electrolyzer can have 1-4 outputs.
<br>
**Fusion Reactor**:

`modSupport.gregtech.fusionReactor.addRecipe(output, input1, input2, duration, energyPerTick, startupEnergy);`
<br>
**Implosion Compressor**:
`modSupport.gregtech.implosionCompressor.addRecipe(output, input, itnt);`

`modSupport.gregtech.implosionCompressor.addRecipe([output1, output2], input, itnt);`
The implosion compressor has an optional byproduct. You don't need the array notation if there is no such byproduct.
<br>
**Industrial Centrifuge**:

`modSupport.gregtech.centrifuge.addRecipe([output1, output2, output3, output3], input, numCells, duration);`

`modSupport.gregtech.centrifuge.addRecipeFuelCan([output1, output2, output3, output4], input, duration);`

The industrial centrifuge can have 1-4 outputs. `addRecipe` will add a regular recipe, taking zero or more tin cells. `addRecipeFuelCan` fills a fuel can when centrifuging. The fuel can must then be replaced with a new one.
<br>
**Industrial Grinder**:

`modSupport.gregtech.grinder.addRecipe(output, input);`

`modSupport.gregtech.grinder.addRecipe([output1, output2, output3, output4], input);`

`modSupport.gregtech.grinder.addRecipe(output, input1, input2);`

`modsupport.gregtech.grinder.addRecipe([output1, output2, output3, output4], input1, input2);`

The grinder can take 1 or 2 inputs and can produce 1-4 outputs. If there is only one output, the array notation can be skipped.
<br>
**Lathe**:

`modSupport.gregtech.lathe.addRecipe(output, input, duration, euPerTick);`

`modSupport.gregtech.lathe.addRecipe([output1, output2], input, duration, euPerTick);`

The lathe can produce 1 or 2 outputs. If there is only one output, the array notation can be skipped.
<br>
**Plate Bender**:

`modSupport.gregtech.plateBender.addRecipe(output, input, duration, euPerTick);`
<br>
**Sawmill**:
`modSupport.gregtech.sawmill.addRecipe(output, input);`
`modSupport.gregtech.sawmill.addRecipe([output1, output2, output3, output4], input);`
`modSupport.gregtech.sawmill.addRecipe(output, input, cells);`
`modsupport.gregtech.sawmill.addRecipe([output1, output2, output3, output4], input, cells);`
The sawmill can produce 1-4 outputs and may or may not take water cells. If there is only 1 output, the array notation can be skipped.

**Vacuum Freezer**:
`modSupport.gregtech.vacuumFreezer.addRecipe(output, input, duration);`

**Wiremill**:
`modSupport.gregtech.wiremill.addRecipe(output, input, duration, euPerTick);`

New fuels for **Generators**:
`modSupport.gregtech.dieselGenerator.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.dieselGenerator.addFuel(item, euPerMillibucket, output);`
`modSupport.gregtech.gasTurbine.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.gasTurbine.addFuel(item, euPerMillibucket, output);`
`modSupport.gregtech.thermalGenerator.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.thermalGenerator.addFuel(item, euPerMillibucket, output);`
`modSupport.gregtech.denseFluidGenerator.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.denseFluidGenerator.addFuel(item, euPerMillibucket, output);`
`modSupport.gregtech.plasmaGenerator.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.plasmaGenerator.addFuel(item, euPerMillibucket, output);`
`modSupport.gregtech.magicGenerator.addFuel(item, euPerMillibucket);`
`modSupport.gregtech.magicGenerator.addFuel(item, euPerMillibucket, output);`

If the item is a liquid container, it will fill the generator with the content of the container and generate the set amount of EU per millibucket of liquid. Additionally, if the item is a liquid container, the generator may also accept liquids of that type. If the item is not a liquid container, it will generate the equivalent of 1 bucket (= 1000 millibuckets).
<br>
## Forestry
Recipes can be added to the **Forestry** machines, but not removed. Additionally, recipe alterations cannot be undone, meaning that the client will have to be restarted to join another game.

**Bees**: bee genes can be blacklisted

`modSupport.forestry.bees.blacklist("the.internal.gene.name");`

If you don't know the full internal name of the gene, you can print the list of genes to the development console:

`modSupport.forestry.bees.printGenes();`

Make sure to keep the development console open to see the output - see instructions on the beginning of this post. You should recognize your gene in the list. You can blacklist any gene. If a gene is blacklisted, it cannot be obtained through mutation.
<br>
**Biogas Engine**:

`modSupport.forestry.biogasEngine.addFuel(liquid, powerPerCycle, burnDuration);`

`modSupport.forestry.biogasEngine.addFuel(liquid, powerPerCycle, burnDuration, heatFactor);`

`modSupport.forestry.biogasEngine.removeFuel(liquid);`

`powerPerCycle` provides the amount of energy per engine stroke. `burnDuration` is expressed in the number of engine strokes. `heatFactor` can be used to heat up the engine more quickly.
<br>
**Biogenerator**:
`modSupport.forestry.bioGenerator.addFuel(liquid * amount, euPerTick, ticksPerMillibucket);`
`modSupport.forestry.bioGenerator.removeFuel(liquid);`
<br>
**Carpenter**:

`modSupport.forestry.carpenter.addRecipe(output, [[input11, input12, input22], [input21, input22, input23], [input31, input32, input33]]);`

`modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box);`

`modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box, time);`

`modSupport.forestry.carpenter.addRecipe(output, [[recipe]], box, time, liquid * amountOfMillibuckets);`

The recipe input can be any valid recipe input, including ore dictionary entries. The box parameter can be null and makes the recipe require a certain container. The input recipe can be any size from 1x1 to 3x3 but must always be a two-dimensional array.
<br>
**Centrifuge**:
`modSupport.forestry.centrifuge.addRecipe(output, input, time);`
`modSupport.forestry.centrifuge.addRecipe([output1, output2, ...], input, time);`
`modSupport.forestry.centrifuge.addRecipe([output1, output2, ...], input, time, [probability1, probability2, ...]);`

A centrifuge may output any number of items. If no item probabilities are provided, they are assumed to be 100%. If there are more items than probabilities, the remaining items will be generated with a probability of 100%. If there are more probabilities than items, they will be ignored. The centrifuge does not support ore dictionary entries for its input.
<br>
**Fabricator**: it is possible to add new recipes, both with existing and new liquids. New items can be specified to be smelted into liquids internally.

`modSupport.forestry.fabricator.addRecipe(output, [[inputRecipe]], liquid);`

`modSupport.forestry.fabricator.addRecipe(output, [[inputRecipe]], liquid, castItem);`

`modSupport.forestry.fabricator.addSmelting(liquid * amountInMillibuckets, item, meltingPoint);`

The input recipe can be a 1x1 to 3x3 twodimensional array, just like shaped recipes. The recipe items can be items or ore dictionary entries. Recipes may or may not require a cast.
<br>
**Fermenter**: new recipes can be added, as well as new fuels for fermentation.

`modSupport.forestry.fermenter.addRecipe(output, input, outputValue);`
`modSupport.forestry.fermenter.addRecipe(output, input, outputValue, modifier);`
`modSupport.forestry.fermenter.addRecipe(output, input, outputValue, modifier, inputLiquid * amount);`
`modSupport.forestry.fermenter.addFuel(item, fermentPerCycle, cycles);
modSupport.forestry.fermenter.removeFuel(item);`

The modifier value can increase the amount of fermented output generated. The input liquid can make the fermenter accept liquid as well.
<br>
**Moistener**: new recipes can be added as well as new fuels for moistening.

`modSupport.forestry.fermenter.addRecipe(output, input, time);`

`modSupport.forestry.fermenter.addFuel(fuelItem, output, moistenerValue, stage);`

`modSupport.forestry.fermenter.removeFuel(fuelItem);`

The stage value indicates the priority of the fuel items: items with a lower stage value will be consumed first.
<br>
**Peat-fired Engine**: fuels can be added or removed

`modSupport.forestry.peatFiredEngine.addFuel(item, powerPerCycle, numCycles);`

`modSupport.forestry.peatFiredEngine.removeFuel(item);`
<br>
**Rainmaker**: rainmaking and rain-stopping items can be added or removed:

`modSupport.forestry.rainmaker.addRainItem(item, duration, speed);`

`modSupport.forestry.rainmaker.addStopItem(item, duration, speed);`

`modSupport.forestry.rainmaker.removeItem(item);`

Speed indicates how fast the rain starts or stops. Duration indicates the amount of ticks the rain will last.
<br>
**Squeezer**:

`modSupport.forestry.squeezer.addRecipe(output, input, time);`

`modSupport.forestry.squeezer.addRecipe(output, [input1, input2, ...], time);`

`modSupport.forestry.squeezer.addRecipe(output, input, time, remnant);`

`modSupport.forestry.squeezer.addRecipe(output, [inputs], time, remnant);`

`modSupport.forestry.squeezer.addRecipe(output, input, time, remnant, remnantChance);`

`modSupport.forestry.squeezer.addRecipe(output, [inputs], time, remnant, remnantChance);`

The squeezer recipes accept one ore more inputs. If there is only one input, the array notation can be skipped. Stack sizes are taken into account. Recipes can have a remaining item and a 1-100 value representing the chance of retrieving it.

**Still**:

`modSupport.forestry.still.addRecipe(output, input, cyclesPerUnit);`
<br>

## Known bugs
- Sometimes removing recipes for IC2 machines doesn't work. This seems caused by IC2 code.
- Assembly table recipes added by server scripts don't show up in NEI. This seems a NEI problem.
- In 1.6.2 and 1.6.4, server scripts can't alter item names.
